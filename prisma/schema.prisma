generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  client
  analyst
  admin
}

enum CaseStatus {
  intake
  in_progress
  monitoring
  closed
}

enum TargetType {
  social
  broker
  forum
  blog
  engine
}

enum RequestKind {
  GDPR_ERASURE
  CCPA_DELETE
  DEINDEX
}

enum RequestStatus {
  draft
  sent
  ack
  done
  rejected
}

codex/update-snapshots-and-commit-changes-o58o1v
enum TicketType {
  general
  erasure
  deindex
  incident
  other
}

enum TicketPriority {
  low
  medium
  high
  urgent
}

enum TicketStatus {
  inbox
  triage
  in_progress
  waiting_client
  resolved
  closed
}


 main
enum SentVia {
  EMAIL
  PDF_ONLY
}

enum Severity {
  low
  med
  high
}

enum TaskType {
  scan
  dsar_send
  followup
}

enum TaskStatus {
  queued
  running
  done
  error
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  name          String?
  role          Role           @default(client)
  createdAt     DateTime       @default(now())

}

model ClientProfile {
  userId       String   @id
  aliases      String[] @default([])
  city         String?
  consentFlags Json
  kycStatus    KycStatus @default(UNVERIFIED)
  idDocs       Json[]    @default([])
  user         User      @relation(fields: [userId], references: [id])
}

enum KycStatus {
  UNVERIFIED
  PENDING
  VERIFIED
}

model Case {
  id           String        @id @default(uuid())
  userId       String
  status       CaseStatus    @default(intake)
  progress     Int           @default(0)
  createdAt    DateTime      @default(now())
  user         User          @relation(fields: [userId], references: [id])
  targets      Target[]
  requests     Request[]
  scanFindings ScanFinding[]
  tasks        Task[]
  auditLogs    AuditLog[]
  invoices     Invoice[]
}

model Target {

  caseId   String
  domain   String
  type     TargetType
  notes    String?

  requests Request[]
}

model Request {
  id       String        @id @default(uuid())
  caseId   String
  kind     RequestKind
  status   RequestStatus @default(draft)
  legalBasis     String
  recipientEmail String
  recipientName  String?
  payload        Json
  attachments    Json[]      @default([])
  sentVia        SentVia?
  pdfPath        String?
  createdAt      DateTime    @default(now())
  dueAt          DateTime
  sentAt         DateTime?
  case           Case        @relation(fields: [caseId], references: [id])
}

model ScanFinding {
  id          String   @id @default(uuid())
  caseId      String
  url         String
  domain      String
  title       String?
  snippet     String?
  severity    Severity
  firstSeenAt DateTime
  lastSeenAt  DateTime
  case        Case     @relation(fields: [caseId], references: [id])
}

model Task {

}

model AuditLog {
  id          String   @id @default(uuid())
  actorUserId String?
  caseId      String?
  action      AuditAction
  details     Json
  createdAt   DateTime @default(now())
  actor       User?    @relation("AuditLogsActor", fields: [actorUserId], references: [id])
  case        Case?    @relation(fields: [caseId], references: [id])
}

 codex/update-snapshots-and-commit-changes-o58o1v
model Ticket {
  id          String        @id @default(uuid())
  code        String        @unique
  title       String
  description String
  type        TicketType    @default(general)
  priority    TicketPriority @default(medium)
  status      TicketStatus  @default(inbox)
  requesterId String
  assigneeId  String?
  caseId      String?
  tags        String[]      @default([])
  dueAt       DateTime?
  closedAt    DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  requester   User          @relation("TicketRequester", fields: [requesterId], references: [id])
  assignee    User?         @relation("TicketAssignee", fields: [assigneeId], references: [id])
  case        Case?         @relation(fields: [caseId], references: [id])
  comments    TicketComment[]
  events      TicketEvent[]
}

model TicketComment {
  id          String   @id @default(uuid())
  ticketId    String
  authorId    String
  body        String
  internal    Boolean  @default(false)
  attachments Json[]   @default([])
  createdAt   DateTime @default(now())
  ticket      Ticket   @relation(fields: [ticketId], references: [id])
  author      User     @relation(fields: [authorId], references: [id])
}

model TicketEvent {
  id          String         @id @default(uuid())
  ticketId    String
  type        TicketEventType
  payload     Json
  createdAt   DateTime       @default(now())
  actorUserId String?
  ticket      Ticket         @relation(fields: [ticketId], references: [id])
  actor       User?          @relation(fields: [actorUserId], references: [id])
}

enum TicketEventType {
  created
  updated
  status_changed
  assignee_changed
  comment_added
  attachment_added
  emailed
}

model SLASetting {
  id                   String     @id @default(uuid())
  name                 String
  forType              TicketType
  targetResponseHours  Int
  targetResolutionHours Int
  active               Boolean    @default(true)
}

model NotificationSetting {
  id            String  @id @default(uuid())
  userId        String  @unique
  emailOnAssign Boolean @default(true)
  emailOnStatus Boolean @default(true)
  user          User    @relation(fields: [userId], references: [id])
}

 main
enum AuditAction {
  REQUEST_CREATE
  REQUEST_SEND
  REQUEST_FAIL
 codex/update-snapshots-and-commit-changes-o58o1v
  TICKET_CREATE
  TICKET_UPDATE
  TICKET_COMMENT
  TICKET_STATUS
  TICKET_ASSIGN
  TICKET_CLOSE

 main
}

model Invoice {
  id        String   @id @default(uuid())
  caseId    String?
  case      Case?    @relation(fields: [caseId], references: [id])
  createdAt DateTime @default(now())
}
